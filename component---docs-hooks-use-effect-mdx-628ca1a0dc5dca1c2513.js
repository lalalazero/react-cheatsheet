(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{Pjga:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return r})),n.d(t,"default",(function(){return u}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk"),n("mXGw");var a=n("/FXl"),c=n("TjRS"),b=n("Xk6X");n("aD51");function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!r.hasOwnProperty("__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/hooks/useEffect.mdx"}});var p={_frontmatter:r},i=c.a;function u(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,c={},b=Object.keys(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||(c[n]=e[n]);return c}(e,["components"]);return Object(a.b)(i,l({},p,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"基础用法"},"基础用法"),Object(a.b)("p",null,"第一次 render 以及 点击按钮 +1 每次导致组件 re-render 都会执行 useEffect, 更新 document.title"),Object(a.b)(b.b,{mdxType:"BasicEffect"}),Object(a.b)("h2",{id:"多个-useeffect"},"多个 useEffect"),Object(a.b)("p",null,"多个 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 按照顺序执行。（注意：如果混用了 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 和 ",Object(a.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," 可能执行顺序会有差别）"),Object(a.b)(b.e,{mdxType:"MultipleEffect"}),Object(a.b)("h2",{id:"依赖空数组"},"依赖空数组"),Object(a.b)("p",null,"依赖是空数组的的 useEffect ，只会在第一次 render 执行，相当于 componentDidMount ，但是两者还是有不同的。（具体不同?）由于 props 变化带来的 re-render 不会执行。"),Object(a.b)(b.d,{mdxType:"EmptyDependency"}),Object(a.b)("p",null,"对于没有依赖的 useEffect , 每次组件 render 都会重新执行，所以千万不要写这种代码，死循环没商量："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"useEffect(() => {\n    setState(xxx)\n})\n")),Object(a.b)("p",null,"同理，class 组件也不能写这种代码:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"class Foo extends React.Component {\n    render() {\n        this.setState({})\n    }\n}\n")),Object(a.b)("h2",{id:"依赖不为空数组"},"依赖不为空数组"),Object(a.b)("p",null,"对于依赖不为空的数组，当依赖有更新时的 render 会去执行 useEffect。所以 App 组件的 re-render 不会执行 Foo 组件的 useEffect, 因为 count 不受影响，还是没变的。"),Object(a.b)(b.a,{mdxType:"AccurateDependency"}),Object(a.b)("h2",{id:"cleanup"},"cleanup"),Object(a.b)("p",null,"在运行下一次 effect 之前把前一个 effect 清理掉，背后的设计思想是 y=f(x) 也是函数式的。即便是 effect ，也属于某一次的 render。cleanup 也遵循依赖数组的规则。"),Object(a.b)(b.c,{mdxType:"CleanupEffect"}),Object(a.b)("h4",{id:"设想如果不清理掉前一次的-effect，会造成什么后果？"},"设想如果不清理掉前一次的 effect，会造成什么后果？"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"如果是给 DOM 绑定的事件监听不移除，很有可能造成内存泄漏。"),Object(a.b)("li",{parentName:"ol"},"当你的 effect 依赖的 props 发生了改变，但是没有清理之前的 effect，那么之前的 effect 的执行结果就是错的。比如：",Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"useEffect(() => {\n    subscribeToDoSomething(props.Id, handler)\n    return unsubscribeToDoSomething(props.Id, handler)\n}, [props.Id])\n")))),Object(a.b)("h2",{id:"要点总结"},"要点总结"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"useEffect(effectFunction, arrayDependency)")),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"什么是副作用"),Object(a.b)("p",{parentName:"li"},"请求数据、添加事件监听、直接修改 DOM、打印日志 log 等操作都属于此类。根据是否需要 cleanup ，又分为"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"不需要 cleanup ",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"打印日志 log"),Object(a.b)("li",{parentName:"ul"},"请求数据"),Object(a.b)("li",{parentName:"ul"},"直接修改 DOM"))),Object(a.b)("li",{parentName:"ul"},"需要 cleanup ",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"setTimeout setInterval 定时器"),Object(a.b)("li",{parentName:"ul"},"事件监听函数"),Object(a.b)("li",{parentName:"ul"},"其他发布订阅事件"))))),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"useEffect 解决了什么问题"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"函数式组件可以有类似 class 组件的钩子"),Object(a.b)("li",{parentName:"ul"},"class 组件的 didMount 和 DidUpdate 通常有很多冗余代码，而且和 class 组件强绑定，无法抽取。 useEffect 可以将这些过程代码按照逻辑单独抽取，各自执行。"),Object(a.b)("li",{parentName:"ul"},"class 组件的绑定函数 bind this 问题"))),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"useEffect 类比 class 组件三个钩子结合体 "),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"componentDidMount")," "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"componentDidUpdate"),"  "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"componentWillUnmount")))),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"useEffect 总是会在 render 之后执行（包括 first render 和 after every update) "),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"除非用依赖数组添加控制")))))}void 0!==u&&u&&u===Object(u)&&Object.isExtensible(u)&&!u.hasOwnProperty("__filemeta")&&Object.defineProperty(u,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/hooks/useEffect.mdx"}}),u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-hooks-use-effect-mdx-628ca1a0dc5dca1c2513.js.map