(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{"9pMP":function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return c})),a.d(t,"default",(function(){return p}));a("5hJT"),a("W1QL"),a("K/PF"),a("t91x"),a("75LO"),a("PJhk"),a("mXGw");var n=a("/FXl"),b=a("TjRS"),r=a("6xeW"),l=a("QrTU");a("aD51");function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/hooks/useState.mdx"}});var o={_frontmatter:c},s=b.a;function p(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,b={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(b[a]=e[a]);return b}(e,["components"]);return Object(n.b)(s,i({},o,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("h2",{id:"知识要点"},"知识要点"),Object(n.b)("p",null,Object(n.b)("inlineCode",{parentName:"p"},"useState")," 作用在函数式组件中，可以让函数式组件像 Class 组件一样拥有状态。",Object(n.b)("inlineCode",{parentName:"p"},"[state, setState] = useState()")),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"useState 的初始值可以是任意的值"),Object(n.b)("li",{parentName:"ol"},"useState 的初始化可以接受一个函数"),Object(n.b)("li",{parentName:"ol"},"useState 的 state 变化会导致当前函数组件的 re-render"),Object(n.b)("li",{parentName:"ol"},"useState 是按照顺序执行的"),Object(n.b)("li",{parentName:"ol"},"useState 不能写在条件语句中(why?)"),Object(n.b)("li",{parentName:"ol"},"setState 也可以接受一个函数 ",Object(n.b)("inlineCode",{parentName:"li"},"setState((prevState) => newState)"))),Object(n.b)("h2",{id:"基础用法"},"基础用法"),Object(n.b)(r.c,{mdxType:"Starter"}),Object(n.b)("h2",{id:"实现原理"},"实现原理"),Object(n.b)("p",null,"利用闭包实现一个 ",Object(n.b)("inlineCode",{parentName:"p"},"MyUseState"),"，功能类似 ",Object(n.b)("inlineCode",{parentName:"p"},"useState")),Object(n.b)(r.a,{mdxType:"MyUseStateDemo01"}),Object(n.b)("p",null,"单次使用 myUseState 看起来已经可以了，多次使用呢？会有问题。\n继续改造，把 state 作为数组，增加一个 index 记录 MyUseState 出现的位置，每次 re-render 的时候保证按照这个顺序依次调用（\n这样同时能拿到 index 对应的 state ），这也是为什么 useState 不能出现在条件语句中，必须保证每次 render 的时候调用顺序都完全一致。"),Object(n.b)(r.b,{mdxType:"MyUseStateDemo02"}),Object(n.b)("p",null,"可以看到每次 state 的更新带来的 re-render 都会按照顺序再次执行 useState（注意 render 的时候 index 都会重置为 0 ), 只是每个单独的 state 的值都被闭包缓存了下来。"),Object(n.b)("h2",{id:"总结真正的-react-世界"},"总结真正的 React 世界"),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"一个函数组件就是一个 React 节点(",Object(n.b)("inlineCode",{parentName:"li"},"FiberNode"),")，每个组件都有一个自己的 _state 和 index"),Object(n.b)("li",{parentName:"ol"},"_state 对应的是 memorizedState, index 的实现用到了链表"),Object(n.b)("li",{parentName:"ol"},"useState 读取 _state","[index]","，并返回闭包得到的最新的值"),Object(n.b)("li",{parentName:"ol"},"index 由 useState 出现的顺序决定（为了保证执行顺序，useState 绝对不能写在条件语句里）"),Object(n.b)("li",{parentName:"ol"},"setState 会触发当前组件重新执行，并再次按照顺序执行 useState")),Object(n.b)("p",null,"参考："),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},Object(n.b)("a",i({parentName:"li"},{href:"https://static.xiedaimala.com/xdml/file/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2020-3-24-9-43-8.pdf"}),"https://static.xiedaimala.com/xdml/file/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2020-3-24-9-43-8.pdf")),Object(n.b)("li",{parentName:"ol"},Object(n.b)("a",i({parentName:"li"},{href:"https://juejin.im/post/5bdfc1c4e51d4539f4178e1f"}),"https://juejin.im/post/5bdfc1c4e51d4539f4178e1f"))),Object(n.b)("h2",{id:"其他发散---过时闭包-stale-closure"},"其他发散 - 过时闭包 Stale Closure"),Object(n.b)(l.a,{mdxType:"StaleClosure"}))}void 0!==p&&p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/hooks/useState.mdx"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-hooks-use-state-mdx-6bfcb6ed9ad6d85e8aa0.js.map