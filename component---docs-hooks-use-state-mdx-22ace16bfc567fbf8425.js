(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{"9pMP":function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return c})),a.d(t,"default",(function(){return s}));a("5hJT"),a("W1QL"),a("K/PF"),a("t91x"),a("75LO"),a("PJhk"),a("mXGw");var n=a("/FXl"),b=a("TjRS"),i=a("6xeW"),r=a("QrTU");a("aD51");function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/hooks/useState.mdx"}});var o={_frontmatter:c},p=b.a;function s(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,b={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(b[a]=e[a]);return b}(e,["components"]);return Object(n.b)(p,l({},o,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("h2",{id:"基础用法"},"基础用法"),Object(n.b)(i.c,{mdxType:"Starter"}),Object(n.b)("h2",{id:"state-是复杂对象"},"state 是复杂对象"),Object(n.b)("p",null,"当 ",Object(n.b)("inlineCode",{parentName:"p"},"state")," 是一个复杂对象时， ",Object(n.b)("inlineCode",{parentName:"p"},"setState")," 的时候要注意返回一个完整的 ",Object(n.b)("inlineCode",{parentName:"p"},"state")," ，因为 ",Object(n.b)("inlineCode",{parentName:"p"},"setState")," 不会帮你做属性合并。示例如下，当更新地址时， ",Object(n.b)("inlineCode",{parentName:"p"},"age")," 和 ",Object(n.b)("inlineCode",{parentName:"p"},"name")," 都丢失了。正确的做法是 ",Object(n.b)("inlineCode",{parentName:"p"},"setStudent({...student, location: { region: 'CN', city: 'beijing'}})")," 。\n还需要注意 ",Object(n.b)("inlineCode",{parentName:"p"},"setState(obj)")," 时， ",Object(n.b)("inlineCode",{parentName:"p"},"obj")," 的地址如果没变，也是不会 ",Object(n.b)("inlineCode",{parentName:"p"},"re-render")," 的。"),Object(n.b)(i.d,{mdxType:"StateIsObject"}),Object(n.b)("h2",{id:"实现原理"},"实现原理"),Object(n.b)("p",null,"利用闭包实现一个 ",Object(n.b)("inlineCode",{parentName:"p"},"MyUseState"),"，功能类似 ",Object(n.b)("inlineCode",{parentName:"p"},"useState")),Object(n.b)(i.a,{mdxType:"MyUseStateDemo01"}),Object(n.b)("p",null,"单次使用 myUseState 看起来已经可以了，多次使用呢？会有问题。\n继续改造，把 state 作为数组，增加一个 index 记录 MyUseState 出现的位置，每次 re-render 的时候保证按照这个顺序依次调用（\n这样同时能拿到 index 对应的 state ），这也是为什么 useState 不能出现在条件语句中，必须保证每次 render 的时候调用顺序都完全一致。"),Object(n.b)(i.b,{mdxType:"MyUseStateDemo02"}),Object(n.b)("p",null,"可以看到每次 state 的更新带来的 re-render 都会按照顺序再次执行 useState（注意 render 的时候 index 都会重置为 0 ), 只是每个单独的 state 的值都被闭包缓存了下来。"),Object(n.b)("h2",{id:"真正的-react-世界"},"真正的 React 世界"),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"一个函数组件就是一个 React 节点(",Object(n.b)("inlineCode",{parentName:"li"},"FiberNode"),")，每个组件都有一个自己的 _state 和 index"),Object(n.b)("li",{parentName:"ol"},"_state 对应的是 memorizedState, index 的实现用到了链表"),Object(n.b)("li",{parentName:"ol"},"useState 读取 _state","[index]","，并返回闭包得到的最新的值"),Object(n.b)("li",{parentName:"ol"},"index 由 useState 出现的顺序决定（为了保证执行顺序，useState 绝对不能写在条件语句里）"),Object(n.b)("li",{parentName:"ol"},"setState 会触发当前组件重新执行，并再次按照顺序执行 useState")),Object(n.b)("p",null,"参考："),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},Object(n.b)("a",l({parentName:"li"},{href:"https://static.xiedaimala.com/xdml/file/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2020-3-24-9-43-8.pdf"}),"https://static.xiedaimala.com/xdml/file/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2020-3-24-9-43-8.pdf")),Object(n.b)("li",{parentName:"ol"},Object(n.b)("a",l({parentName:"li"},{href:"https://juejin.im/post/5bdfc1c4e51d4539f4178e1f"}),"https://juejin.im/post/5bdfc1c4e51d4539f4178e1f"))),Object(n.b)("h2",{id:"其他发散---过时闭包-stale-closure"},"其他发散 - 过时闭包 Stale Closure"),Object(n.b)(r.a,{mdxType:"StaleClosure"}),Object(n.b)("h2",{id:"要点总结"},"要点总结"),Object(n.b)("p",null,Object(n.b)("inlineCode",{parentName:"p"},"useState")," 作用在函数式组件中，可以让函数式组件像 Class 组件一样拥有状态。",Object(n.b)("inlineCode",{parentName:"p"},"[state, setState] = useState(initState)")),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"useState 的初始值可以是任意的值"),Object(n.b)("li",{parentName:"ol"},"useState 的初始化可以接受一个函数"),Object(n.b)("li",{parentName:"ol"},"useState 的 state 变化会导致当前函数组件的 re-render"),Object(n.b)("li",{parentName:"ol"},"useState 是按照顺序执行的"),Object(n.b)("li",{parentName:"ol"},"useState 不能写在条件语句中(why?)"),Object(n.b)("li",{parentName:"ol"},"setState 也可以接受一个函数 ",Object(n.b)("inlineCode",{parentName:"li"},"setState((prevState) => newState)"))))}void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/hooks/useState.mdx"}}),s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-hooks-use-state-mdx-22ace16bfc567fbf8425.js.map