{"version":3,"sources":["webpack:///../docs/hooks/useEffect.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"8fAOO,IAAMA,EAAe,Q,0MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,iBAAQ,CACN,GAAM,QADR,QAGA,iGACA,YAAC,IAAD,CAAaA,QAAQ,gBACrB,iBAAQ,CACN,GAAM,gBADR,gBAGA,2BAAU,0BAAYC,WAAW,KAAvB,aAAV,WACA,YAAC,IAAD,CAAgBD,QAAQ,mBACxB,iBAAQ,CACN,GAAM,WADR,WAGA,2GACA,YAAC,IAAD,CAAeA,QAAQ,kBACvB,iBAAQ,CACN,GAAM,SADR,SAGA,0EACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,iBADZ,+CAML,qIACA,YAAC,IAAD,CAAiBD,QAAQ,oBACzB,iBAAQ,CACN,GAAM,WADR,WAGA,iBAAQ,CACN,GAAM,QADR,QAGA,qBAAG,0BAAYC,WAAW,KAAvB,+CACH,sBACE,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,UACA,iBAAGA,WAAW,MAAd,8DACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAf,eAAoC,kBAAIA,WAAW,MAC/C,kBAAIA,WAAW,MAAf,YACA,kBAAIA,WAAW,MAAf,QACA,kBAAIA,WAAW,MAAf,cAEJ,kBAAIA,WAAW,MAAf,cAAmC,kBAAIA,WAAW,MAC9C,kBAAIA,WAAW,MAAf,8BACA,kBAAIA,WAAW,MAAf,cAIR,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,qBACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAf,0BACA,kBAAIA,WAAW,MAAf,oGACA,kBAAIA,WAAW,MAAf,gCAGJ,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,iCACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAvB,qBAApB,KACA,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAvB,sBAApB,MACA,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAvB,2BAGxB,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,qEACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAf,wB,wMAQVJ,EAAWK,gBAAiB","file":"component---docs-hooks-use-effect-mdx-d8715fbd192bd57a2830.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/react-cheatsheet/react-cheatsheet/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { BasicEffect, MultipleEffect, CleanupEffect, EmptyDependency } from '../../component/hooks/UseEffect';\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h2 {...{\n      \"id\": \"基础用法\"\n    }}>{`基础用法`}</h2>\n    <p>{`第一次 render 以及 点击按钮 +1 每次导致组件 re-render 都会执行 useEffect, 更新 document.title`}</p>\n    <BasicEffect mdxType=\"BasicEffect\" />\n    <h2 {...{\n      \"id\": \"多个-useeffect\"\n    }}>{`多个 useEffect`}</h2>\n    <p>{`多个 `}<inlineCode parentName=\"p\">{`useEffect`}</inlineCode>{` 按照顺序执行`}</p>\n    <MultipleEffect mdxType=\"MultipleEffect\" />\n    <h2 {...{\n      \"id\": \"cleanup\"\n    }}>{`cleanup`}</h2>\n    <p>{`在运行下一次 effect 之前把前一个 effect 清理掉，背后的设计思想是 y=f(x) 也是函数式的。即便是 effect ，也属于某一次的 render。`}</p>\n    <CleanupEffect mdxType=\"CleanupEffect\" />\n    <h2 {...{\n      \"id\": \"依赖空数组\"\n    }}>{`依赖空数组`}</h2>\n    <p>{`对于没有依赖的 useEffect , 每次组件 render 都会重新执行。千万不要写这种代码：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`useEffect(() => {\n    setState(xxx)\n})\n`}</code></pre>\n    <p>{`依赖是空数组的的 useEffect ，只会在第一次 render 执行，相当于 componentDidMount ，但是两者还是有不同的。（具体不同?）由于 props 变化带来的 re-render 不会执行。`}</p>\n    <EmptyDependency mdxType=\"EmptyDependency\" />\n    <h2 {...{\n      \"id\": \"依赖不为空数组\"\n    }}>{`依赖不为空数组`}</h2>\n    <h2 {...{\n      \"id\": \"要点总结\"\n    }}>{`要点总结`}</h2>\n    <p><inlineCode parentName=\"p\">{`useEffect(effectFunction, arrayDependency)`}</inlineCode></p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`什么是副作用`}</p>\n        <p parentName=\"li\">{`请求数据、添加事件监听、直接修改 DOM、打印日志 log 等操作都属于此类。根据是否需要 cleanup ，又分为`}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`不需要 cleanup `}<ul parentName=\"li\">\n              <li parentName=\"ul\">{`打印日志 log`}</li>\n              <li parentName=\"ul\">{`请求数据`}</li>\n              <li parentName=\"ul\">{`直接修改 DOM`}</li>\n            </ul></li>\n          <li parentName=\"ul\">{`需要 cleanup `}<ul parentName=\"li\">\n              <li parentName=\"ul\">{`setTimeout setInterval 定时器`}</li>\n              <li parentName=\"ul\">{`事件监听函数`}</li>\n            </ul></li>\n        </ul>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`useEffect 解决了什么问题`}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`函数式组件可以有类似 class 组件的钩子`}</li>\n          <li parentName=\"ul\">{`class 组件的 didMount 和 DidUpdate 通常有很多冗余代码，而且和 class 组件强绑定，无法抽取。 useEffect 可以将这些过程代码按照逻辑单独抽取，各自执行。`}</li>\n          <li parentName=\"ul\">{`class 组件的绑定函数 bind this 问题`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`useEffect 类比 class 组件三个钩子结合体 `}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`componentDidMount`}</inlineCode>{` `}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`componentDidUpdate`}</inlineCode>{`  `}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`componentWillUnmount`}</inlineCode></li>\n        </ul>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`useEffect 总是会在 render 之后执行（包括 first render 和 after every update) `}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`除非用依赖数组添加控制`}</li>\n        </ul>\n      </li>\n    </ol>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}