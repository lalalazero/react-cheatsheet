{"version":3,"sources":["webpack:///../docs/hooks/useMemo.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ggBAOO,IAAMA,EAAe,Q,wMAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,aADR,cAIA,iEACA,YAAC,IAAD,CAAaA,QAAQ,gBACrB,qEAAoD,0BAAYC,WAAW,KAAvB,cAApD,6DACA,YAAC,IAAD,CAAUD,QAAQ,aAClB,yDAAwC,0BAAYC,WAAW,KAAvB,cAAxC,sIACA,YAAC,IAAD,CAAeD,QAAQ,kBACvB,kIACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,iBADZ,kCAIL,iBAAQ,CACN,GAAM,WADR,WAGA,2EACA,YAAC,IAAD,CAAaD,QAAQ,sB,sMAKzBH,EAAWK,gBAAiB","file":"component---docs-hooks-use-memo-mdx-9de0cfb22487eae38031.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/react-cheatsheet/react-cheatsheet/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { WithoutMemo, WithMemo, WithClickFunc, WithUseMemo } from '../../component/hooks/UseMemo';\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h2 {...{\n      \"id\": \"reactmemo\"\n    }}>{`React.memo`}</h2>\n\n    <p>{`如下示例，当 App 组件更新的时候， Child 组件也会 re-render`}</p>\n    <WithoutMemo mdxType=\"WithoutMemo\" />\n    <p>{`很明显这是可以优化的，而且如果 Child 组件有非常昂贵的计算，这种优化也是必要的。用 `}<inlineCode parentName=\"p\">{`React.memo`}</inlineCode>{` 优化一下之后，更新 n 不会导致 Child 组件的更新，只有当依赖的 m 变化的时候才会 re-render。`}</p>\n    <WithMemo mdxType=\"WithMemo\" />\n    <p>{`如果要给 Child 组件传递一个 onClick 函数怎么办？ `}<inlineCode parentName=\"p\">{`React.memo`}</inlineCode>{` 优化了当 props 变化时才重新更新。 但是 props 有监听函数之后，Child 组件还是会更新，因为每次 App 组件 re-render 都会生成新的 onClick 函数，传递给 Child 组件，所以 Child 组件也会 re-render。`}</p>\n    <WithClickFunc mdxType=\"WithClickFunc\" />\n    <p>{`其实同样的道理在 PureComponent 也是一样的。很多时候会有这样的代码：即便 Child 是一个 PureComponent，但是每次父组件 re-render 的时候还是会导致 Child 的更新。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`<Child onClick={() => {}}/>\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"usememo\"\n    }}>{`useMemo`}</h2>\n    <p>{`使用 useMemo 把函数记忆起来，如果参数没有改变，那么 Child 就不用 re-render`}</p>\n    <WithUseMemo mdxType=\"WithUseMemo\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}