(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{"+Dhe":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return l})),n.d(t,"default",(function(){return m}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk"),n("mXGw");var r=n("/FXl"),o=n("TjRS"),i=n("OEyl");n("aD51");function c(){return(c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/hooks/useMemo.mdx"}});var a={_frontmatter:l},b=o.a;function m(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(r.b)(b,c({},a,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"reactmemo"},"React.memo"),Object(r.b)("p",null,"如下示例，当 App 组件更新的时候， Child 组件也会 re-render"),Object(r.b)(i.d,{mdxType:"WithoutMemo"}),Object(r.b)("p",null,"很明显这是可以优化的，而且如果 Child 组件有非常昂贵的计算，这种优化也是必要的。用 ",Object(r.b)("inlineCode",{parentName:"p"},"React.memo")," 优化一下之后，更新 n 不会导致 Child 组件的更新，只有当依赖的 m 变化的时候才会 re-render。"),Object(r.b)(i.b,{mdxType:"WithMemo"}),Object(r.b)("p",null,"如果要给 Child 组件传递一个 onClick 函数怎么办？ ",Object(r.b)("inlineCode",{parentName:"p"},"React.memo")," 优化了当 props 变化时才重新更新。 但是 props 有监听函数之后，Child 组件还是会更新，因为每次 App 组件 re-render 都会生成新的 onClick 函数，传递给 Child 组件，所以 Child 组件也会 re-render。"),Object(r.b)(i.a,{mdxType:"WithClickFunc"}),Object(r.b)("p",null,"其实同样的道理在 PureComponent 也是一样的。很多时候会有这样的代码：即便 Child 是一个 PureComponent，但是每次父组件 re-render 的时候还是会导致 Child 的更新。"),Object(r.b)("pre",null,Object(r.b)("code",c({parentName:"pre"},{className:"language-jsx"}),"<Child onClick={() => {}}/>\n")),Object(r.b)("h2",{id:"usememo"},"useMemo"),Object(r.b)("p",null,"使用 useMemo 把函数记忆起来，如果参数没有改变，那么 Child 就不用 re-render"),Object(r.b)(i.c,{mdxType:"WithUseMemo"}))}void 0!==m&&m&&m===Object(m)&&Object.isExtensible(m)&&!m.hasOwnProperty("__filemeta")&&Object.defineProperty(m,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/hooks/useMemo.mdx"}}),m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-hooks-use-memo-mdx-9de0cfb22487eae38031.js.map