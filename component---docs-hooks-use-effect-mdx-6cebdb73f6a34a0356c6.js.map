{"version":3,"sources":["webpack:///../docs/hooks/useEffect.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"8fAOO,IAAMA,EAAe,Q,0MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,iBAAQ,CACN,GAAM,QADR,QAGA,iGACA,YAAC,IAAD,CAAaA,QAAQ,gBACrB,iBAAQ,CACN,GAAM,gBADR,gBAGA,2BAAU,0BAAYC,WAAW,KAAvB,aAAV,qBAAqF,0BAAYA,WAAW,KAAvB,aAArF,MAAiJ,0BAAYA,WAAW,KAAvB,mBAAjJ,gBACA,YAAC,IAAD,CAAgBD,QAAQ,mBACxB,iBAAQ,CACN,GAAM,SADR,SAGA,qIACA,YAAC,IAAD,CAAiBA,QAAQ,oBACzB,mFACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,iBADZ,+CAML,6CACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,+FAQL,iBAAQ,CACN,GAAM,WADR,WAGA,oIACA,YAAC,IAAD,CAAoBD,QAAQ,uBAC5B,iBAAQ,CACN,GAAM,WADR,WAGA,8HACA,YAAC,IAAD,CAAeA,QAAQ,kBACvB,iBAAQ,CACN,GAAM,gCADR,gCAGA,sBACE,kBAAIC,WAAW,MAAf,mCACA,kBAAIA,WAAW,MAAf,yEAA8F,mBAAKA,WAAW,MAAK,sBAAMA,WAAW,OAAU,CACxI,UAAa,iBADgG,iJAQrH,iBAAQ,CACN,GAAM,QADR,QAGA,qBAAG,0BAAYA,WAAW,KAAvB,+CACH,sBACE,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,UACA,iBAAGA,WAAW,MAAd,8DACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAf,eAAoC,kBAAIA,WAAW,MAC/C,kBAAIA,WAAW,MAAf,YACA,kBAAIA,WAAW,MAAf,QACA,kBAAIA,WAAW,MAAf,cAEJ,kBAAIA,WAAW,MAAf,cAAmC,kBAAIA,WAAW,MAC9C,kBAAIA,WAAW,MAAf,8BACA,kBAAIA,WAAW,MAAf,UACA,kBAAIA,WAAW,MAAf,gBAIR,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,qBACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAf,0BACA,kBAAIA,WAAW,MAAf,oGACA,kBAAIA,WAAW,MAAf,gCAGJ,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,iCACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAvB,qBAApB,KACA,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAvB,sBAApB,MACA,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAvB,2BAGxB,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,qEACA,kBAAIA,WAAW,MACb,kBAAIA,WAAW,MAAf,wB,wMAQVJ,EAAWK,gBAAiB","file":"component---docs-hooks-use-effect-mdx-6cebdb73f6a34a0356c6.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/react-cheatsheet/react-cheatsheet/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { BasicEffect, MultipleEffect, CleanupEffect, EmptyDependency, AccurateDependency } from '../../component/hooks/UseEffect';\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h2 {...{\n      \"id\": \"基础用法\"\n    }}>{`基础用法`}</h2>\n    <p>{`第一次 render 以及 点击按钮 +1 每次导致组件 re-render 都会执行 useEffect, 更新 document.title`}</p>\n    <BasicEffect mdxType=\"BasicEffect\" />\n    <h2 {...{\n      \"id\": \"多个-useeffect\"\n    }}>{`多个 useEffect`}</h2>\n    <p>{`多个 `}<inlineCode parentName=\"p\">{`useEffect`}</inlineCode>{` 按照顺序执行。（注意：如果混用了 `}<inlineCode parentName=\"p\">{`useEffect`}</inlineCode>{` 和 `}<inlineCode parentName=\"p\">{`useLayoutEffect`}</inlineCode>{` 可能执行顺序会有差别）`}</p>\n    <MultipleEffect mdxType=\"MultipleEffect\" />\n    <h2 {...{\n      \"id\": \"依赖空数组\"\n    }}>{`依赖空数组`}</h2>\n    <p>{`依赖是空数组的的 useEffect ，只会在第一次 render 执行，相当于 componentDidMount ，但是两者还是有不同的。（具体不同?）由于 props 变化带来的 re-render 不会执行。`}</p>\n    <EmptyDependency mdxType=\"EmptyDependency\" />\n    <p>{`对于没有依赖的 useEffect , 每次组件 render 都会重新执行，所以千万不要写这种代码，死循环没商量：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`useEffect(() => {\n    setState(xxx)\n})\n`}</code></pre>\n    <p>{`同理，class 组件也不能写这种代码:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`class Foo extends React.Component {\n    render() {\n        this.setState({})\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"依赖不为空数组\"\n    }}>{`依赖不为空数组`}</h2>\n    <p>{`对于依赖不为空的数组，当依赖有更新时的 render 会去执行 useEffect。所以 App 组件的 re-render 不会执行 Foo 组件的 useEffect, 因为 count 不受影响，还是没变的。`}</p>\n    <AccurateDependency mdxType=\"AccurateDependency\" />\n    <h2 {...{\n      \"id\": \"cleanup\"\n    }}>{`cleanup`}</h2>\n    <p>{`在运行下一次 effect 之前把前一个 effect 清理掉，背后的设计思想是 y=f(x) 也是函数式的。即便是 effect ，也属于某一次的 render。cleanup 也遵循依赖数组的规则。`}</p>\n    <CleanupEffect mdxType=\"CleanupEffect\" />\n    <h4 {...{\n      \"id\": \"设想如果不清理掉前一次的-effect，会造成什么后果？\"\n    }}>{`设想如果不清理掉前一次的 effect，会造成什么后果？`}</h4>\n    <ol>\n      <li parentName=\"ol\">{`如果是给 DOM 绑定的事件监听不移除，很有可能造成内存泄漏。`}</li>\n      <li parentName=\"ol\">{`当你的 effect 依赖的 props 发生了改变，但是没有清理之前的 effect，那么之前的 effect 的执行结果就是错的。比如：`}<pre parentName=\"li\"><code parentName=\"pre\" {...{\n            \"className\": \"language-jsx\"\n          }}>{`useEffect(() => {\n    subscribeToDoSomething(props.Id, handler)\n    return unsubscribeToDoSomething(props.Id, handler)\n}, [props.Id])\n`}</code></pre></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"要点总结\"\n    }}>{`要点总结`}</h2>\n    <p><inlineCode parentName=\"p\">{`useEffect(effectFunction, arrayDependency)`}</inlineCode></p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`什么是副作用`}</p>\n        <p parentName=\"li\">{`请求数据、添加事件监听、直接修改 DOM、打印日志 log 等操作都属于此类。根据是否需要 cleanup ，又分为`}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`不需要 cleanup `}<ul parentName=\"li\">\n              <li parentName=\"ul\">{`打印日志 log`}</li>\n              <li parentName=\"ul\">{`请求数据`}</li>\n              <li parentName=\"ul\">{`直接修改 DOM`}</li>\n            </ul></li>\n          <li parentName=\"ul\">{`需要 cleanup `}<ul parentName=\"li\">\n              <li parentName=\"ul\">{`setTimeout setInterval 定时器`}</li>\n              <li parentName=\"ul\">{`事件监听函数`}</li>\n              <li parentName=\"ul\">{`其他发布订阅事件`}</li>\n            </ul></li>\n        </ul>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`useEffect 解决了什么问题`}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`函数式组件可以有类似 class 组件的钩子`}</li>\n          <li parentName=\"ul\">{`class 组件的 didMount 和 DidUpdate 通常有很多冗余代码，而且和 class 组件强绑定，无法抽取。 useEffect 可以将这些过程代码按照逻辑单独抽取，各自执行。`}</li>\n          <li parentName=\"ul\">{`class 组件的绑定函数 bind this 问题`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`useEffect 类比 class 组件三个钩子结合体 `}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`componentDidMount`}</inlineCode>{` `}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`componentDidUpdate`}</inlineCode>{`  `}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`componentWillUnmount`}</inlineCode></li>\n        </ul>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`useEffect 总是会在 render 之后执行（包括 first render 和 after every update) `}</p>\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`除非用依赖数组添加控制`}</li>\n        </ul>\n      </li>\n    </ol>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}